<!DOCTYPE html> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=global.css rel=stylesheet> <style>main.svelte-1pnr8ds{position:relative;box-sizing:border-box;min-height:100vh;width:100%;padding-top:3.5rem;padding-bottom:2.75rem}main.homepage.svelte-1pnr8ds{padding-right:2rem;padding-left:2rem}.bg.contentPage.svelte-1pnr8ds{padding-left:1rem;padding-right:1rem}@media screen and (min-width:775px){.bg.contentPage.svelte-1pnr8ds{padding-left:calc(75px + 1rem);padding-right:4rem}}.bg.svelte-1pnr8ds{background-size:auto,0;background-repeat:auto,no-repeat}@media screen and (min-width:775px){.bg.svelte-1pnr8ds{background-position:right,left;background-attachment:fixed,fixed;background-repeat:auto,repeat-y;background-size:cover,120px}}a{font-weight:700}nav.svelte-2cyc0n{z-index:20;position:fixed;top:0;left:0;right:0;background-color:#fff;font-weight:300;padding:0 1em 1px;transition:box-shadow .2s;margin:0;display:flex;flex-flow:row nowrap}nav.elevated.svelte-2cyc0n{box-shadow:0 0 .5rem rgba(0,0,0,.3),0 1px #eee}.brand-logo.svelte-2cyc0n{height:1em;transform:scale(1) translateX(0);transition:transform .6s ease-in-out}ul.svelte-2cyc0n{margin:0;padding:0;flex-shrink:0}ul.svelte-2cyc0n:first-child{flex-grow:1}ul.svelte-2cyc0n::after{content:'';display:block;clear:both}li.svelte-2cyc0n{display:block;float:left}.selected.svelte-2cyc0n{position:relative;display:inline-block;font-weight:700}.selected.svelte-2cyc0n::after{position:absolute;content:'';width:calc(100% - 1em);height:2px;background-color:#0460a9;display:block;bottom:-1px}a.svelte-2cyc0n{text-decoration:none;padding:1em .5em;display:block}.summary.svelte-dzuyvs{margin:0 0 1em;padding:1em;border-top:3px solid #000;transition:transform .2s;background-color:#fff;box-shadow:-1em 0 #fff}@media screen and (min-width:775px){.summary.svelte-dzuyvs{float:right;width:20rem;transform:translateX(1rem)}}@media screen and (min-width:1200px){.summary.svelte-dzuyvs{float:right;width:20rem;transform:translateX(3rem)}}.content.svelte-dzuyvs h1,h2,h3,h4,h5,h6{margin:0 0 .5em 0;line-height:1.2}.content.svelte-dzuyvs h1,h1.svelte-dzuyvs{font-weight:700;font-size:3rem;margin-bottom:3rem}.content.svelte-dzuyvs h2{font-size:2rem;font-weight:400}.content.svelte-dzuyvs :not(h1):not(hr)+h2{border-top:1px solid #000;padding-top:1em;margin-top:1em}.content.svelte-dzuyvs h3{color:#0460a9}.content.svelte-dzuyvs pre{background-color:#f9f9f9;box-shadow:inset 1px 1px 5px rgba(0,0,0,.05);padding:.5em;border-radius:2px;overflow-x:auto}.content.svelte-dzuyvs pre code{background-color:transparent;padding:0}.content.svelte-dzuyvs ul{line-height:1.5}.content.svelte-dzuyvs li{margin:0 0 .5em 0}.content.svelte-dzuyvs img{max-width:100%}.content.svelte-dzuyvs table{margin:1em 2em;border-collapse:collapse}.content.svelte-dzuyvs th{text-align:left;padding:0 .5em}.content.svelte-dzuyvs thead th{color:#0460a9;font-weight:700;text-transform:uppercase;border-bottom:1px solid #0460a9}.content.svelte-dzuyvs td{text-align:left;padding:.25em .5em}.callout-wrapper.svelte-dzuyvs>div{margin-top:4rem;margin-left:-1rem;margin-right:-1rem}@media screen and (min-width:775px){.callout-wrapper.svelte-dzuyvs>div{margin-left:calc(-75px - 3rem);margin-right:-4rem}}.btn.svelte-zemmdc,a[role=button]{border:1px solid #000;background-color:#fff;color:#000;transition:color .2s,background-color .2s;font-weight:700;display:inline-flex;align-items:center;justify-content:center;text-decoration:none;padding:.25em .75em;white-space:nowrap;cursor:pointer}.btn.svelte-zemmdc:hover,a[role=button]:hover{background-color:#000;color:#fff}.btn.primary.svelte-zemmdc{border-color:#fff;background-color:#0460a9;color:#fff}.btn.primary.svelte-zemmdc:hover{background-color:#fff;color:#0460a9}.callout.svelte-bf2rc0{background-color:#0460a9;color:#fff;padding:2rem 1rem}@media screen and (min-width:775px){.callout.svelte-bf2rc0{padding-left:calc(75px + 3rem)}}.callout-content.svelte-bf2rc0{max-width:50rem}footer.svelte-1o8yfks{display:flex;flex-flow:row nowrap;font-size:.75rem;padding:.5rem .75rem;align-items:center;border-top:1px solid #eee;position:fixed;bottom:0;left:0;right:0;background-color:#fff}@media screen and (max-width:499px){footer.svelte-1o8yfks{text-align:center;flex-flow:column nowrap}}.footer-left.svelte-1o8yfks{flex-grow:1}.footer-right.svelte-1o8yfks{flex-grow:0}a.svelte-1o8yfks{color:rgba(0,0,0,.5);text-decoration:none;font-weight:400}a.svelte-1o8yfks:hover{text-decoration:underline}.social.svelte-1o8yfks{font-size:.825rem}.social.svelte-1o8yfks a.svelte-1o8yfks{border:1px solid #000;background-color:#fff;color:#000;transition:color .2s,background-color .2s;width:1.5rem;height:1.5rem;display:inline-flex;align-items:center;justify-content:center;text-decoration:none;margin:0 .125rem}.social.svelte-1o8yfks a.svelte-1o8yfks:hover{background-color:#000;color:#fff}.sep.svelte-1o8yfks::before{content:'|'}</style> <noscript id=sapper-head-start></noscript><link href=/favicon.ico rel=icon type=image/ico><link href=/manifest.json rel=manifest><title>JPkl</title><noscript id=sapper-head-end></noscript> <link href=/client/1ef9048e76cf74561a9e/main.js rel=preload as=script><link href=/client/1ef9048e76cf74561a9e/projects_$slug.4.js rel=preload as=script></head> <body> <div id=sapper> <nav class=svelte-2cyc0n> <ul class=svelte-2cyc0n> <li class=svelte-2cyc0n> <a class=svelte-2cyc0n href="">NIBR Open Source</a> </li> </ul> <ul class=svelte-2cyc0n> <li class=svelte-2cyc0n> <a class=svelte-2cyc0n href=https://www.novartis.com rel="nofollow noreferrer" target=_blank> <img alt="Novartis logo" class="svelte-2cyc0n brand-logo" src=/novartis-logo.png> </a> </li> </ul> </nav> <div class="contentPage svelte-1pnr8ds bg" style="background-image:linear-gradient(to right,rgba(255,255,255,0),rgba(255,255,255,0) 75px,rgba(255,255,255,255) 75px,rgba(255,255,255,255)),url(/blue-carbon.png)"> <main class="contentPage svelte-1pnr8ds"> <h1 class=svelte-dzuyvs>JPkl</h1> <div class="svelte-dzuyvs summary"> <h2>Project details</h2> <p>Released 9/18/2018</p> <p><p>Serialize high memory / disk consumption NumPy multidimensional arrays of images into JPEG-Pickle files for low storage cost and decently fast, random access with NumPy-like indexing.</p> <p></p> <a class=svelte-zemmdc class=btn href=https://github.com/novartis/jpkl rel="nofollow noreferrer" target=_blank component=a> GitHub repo </a> </div> <div class="svelte-dzuyvs content"> <p>Serialize high memory / disk consumption NumPy multidimensional arrays of images into JPEG-Pickle files for low storage cost and decently fast, random access with NumPy-like indexing.</p> <p>Code at a glance:</p> <pre><code class=language-python>import numpy as np
from jpkl import JPkl

# Make some arbitrary data. Say we have 512x512 images with time, z depth, and multiple channels.
images = np.zeros((512, 512, 100, 3, 2))

# Automagically encode all 512x512 images into JPEGs.
jpkl_images = JPkl(images)

# Index / slice encoded JPEGs as you would a NumPy array.
# JPEG-encoded slices are decoded and all concatenated into an array on-the-fly.

decoded_images = pkl_images[128:256:2, :, 4, ...]  # decoded_images is a NumPy array

decoded_images.shape  # (64, 512, 14, 15) [array is .squeeze()'d as in NumPy indexing]

# JPkl objects support 3 simple NumPy array properties.
# This means you can sometimes get away with passing a JPkl instead of an array to functions.

jpkl_images.shape    # (512, 512, 100, 3, 2)
jpkl_images.ndim     # 5
jpkl_images.size     # 5505024000 [product of pkl_images.shape elements]

# Pickle your JPkl and save to disk:
jpkl_images.save('pickled_images.jpkl')

# Load a saved JPkl file:
saved_jpkl_images = JPkl.load('pickled_images.jpkl')</code></pre> <p>Note that JPkl data is immutable from the high-level interface.</p> <p>See the Jupyter Notebook demo for a more in-depth walkthrough (as well as a cool HoloViews visualization demo of scrubbing through these multidimensional arrays!).</p> <h2 id=motivation>Motivation</h2> <p>Data from scientific imaging applications (such as microscopy) is often stored as raw, uncompressed data. This is important in cases where accurate quantification on pixel values is necessary. Due to this need, however, these image files (and their corresponding memory footprints) are often large, sometimes approaching 10s (or more) of gigabytes in extreme examples. While memory-mapping these files to access them without loading everything into memory is often a viable option, large I/O speed demands due to the sizes of individual frames makes latency during visualization a possible issue. Additionally, this mapping still does not solve the issue of huge disk space consumption.</p> <p>As such, to facilitate speedy visualization of the raw / completely processed images as well as intermediate stage images (which you may not need to keep the uncompressed pixel values for anyway), it makes sense to lossily compress the images for non-computional, solely visualization purposes. JPkl handles this need by compressing all the individual image slices into JPEGs in memory which can then be serialized out to disk. Depending on image content and JPEG quality level, you can see massive (5-10x +) decreases in file size. In addition, JPkl supports on-the-fly decoding of abitrary slices of the pseudo-NumPy array into true NumPy arrays, meaning when you unpickle the JPkl file, your memory consumption remains as low as the file usage on disk unless you want to convert the whole JPkl into an array at once.</p> <p>Note that JPkl is not limited to using Pickle serialization or JPEG encoding. Extending the <code>JPkl</code> class and changing the implementations of <code>jpkl_obj.save()</code> / <code>JPkl.load()</code> or <code>jpkl_obj.encode_slice()</code> / <code>jpkl_obj.decode_slice()</code> will allow you to use any serialization or encoding you wish as appropriate for your application, respectively.</p> <p>JPkl is most useful in the case where you have:</p> <ul> <li>Large raw image datasets which you would like to visualize (such as in a Jupyter Notebook)</li> <li>Datasets that are highly multi-dimensional (x,y spatial + arbitrary number of time / channel axes)</li> <li>The need to visualize intermediate steps of image processing (which adds a multiplier on disk space consumption if intermediate steps are stored as raw images)</li> <li>The desire to keep all images from a dataset / NumPy array in a single file, rather than all messily dumped as separate .jpgs into the filesystem</li> </ul> <p>JPkl uses the Pillow (PIL fork) library for encoding / decoding JPEG images.</p> <h2 id=attribution>Attribution</h2> <p>This is part of the Open Source at Novartis Institutes for BioMedical Research (NIBR) initiative:</p> <ul> <li><a href=https://opensource.nibr.com/ >Open Source @ NIBR home</a></li> <li><a href=https://github.com/Novartis/ >GitHub organization</a></li> </ul> <p>It is licensed under Apache License, Version 2.0.</p> <p>Maintainer: @zbarry</p> <h2 id=jpkl-class-file-format-specification->JPkl class / file format specification:</h2> <p>JPkls on disk are simply a dictionary of:</p> <pre><code>'header': Tuple of ('JPkl', 'version'), version in set{'1'}
    Used for sanity checking if file on disk is JPkl file and is a loadable version.

'color': bool: if True, this came from a set of images with a color channel.
    Therefore, the third axis [index 2] of the returned stack will be of length 3 for RGB.
    Otherwise, there is no color axis.

'jpeg_quality': int: level of JPEG compression (0-100).

'images': Dictionary of byte streams from Pillow `Image` objects encoding images to `bytes` using `io.BytesIO` memory streams
    Each key of the dictionary is a tuple of (channel 1, channel 2, ...) indices which correspond to a single image
    slice. All images must be of the same width and height (since they are derived from / decoded into NumPy arrays).
    jpkl_obj.images[0, 5, 2], for example, returns a byte stream of the JPEG-encoded image slice which would have
    been accessed in the original NumPy array as `image_array[:, :, 0, 5, 2]`. If the images were RGB, the color
    axis is not a key in the dictionary.

'dim_names': List of strings of axis identities that come after height, width. Does not include color name. Not necessary for JPkl, but included for user's own documentation, if desired.

'dim_sizes': Tuple of the lengths of each channel axis. Does not include [height, width, RGB] axes.

'metadata': Dictionary of arbitrary data for the user's usage. Completely ignored by JPkl.</code></pre><h2 id=installation>Installation</h2> <p><strong>Dependencies (installation is through Anaconda system):</strong></p> <h3 id=jpkl->JPkl:</h3> <ul> <li>Python >= 3.6</li> <li>NumPy</li> <li>Pillow (Python Imaging Library fork)</li> </ul> <h3 id=jupyter-notebook-demo->Jupyter Notebook demo:</h3> <ul> <li>Jupyter Notebook / Lab</li> <li><p>HoloViews and associated libraries:</p> <ul> <li>Param</li> <li>ParamBokeh</li> <li>Bokeh</li> <li>ImaGen</li> </ul> </li> </ul> <h3 id=installation-procedure->Installation procedure:</h3> <p>Default installation including libraries enabling the notebook demo:</p> <pre><code>git clone &lt;&lt;repo>>
cd jpkl
source activate YOURENVNAME
conda env update -f environment.yml
pip install .</code></pre><p>Substitute <code>pip install -e .</code> above if you wish to make edits to the source.</p> <p>While using a Conda environment is highly recommended in general, you can technically leave out the the <code>source activate YOURENVNAME</code> line to install to the default package folder. If you've not used Conda environments before, you can create one with <code>conda create -n YOURENVNAME</code> and then activate it with <code>source activate YOURENVNAME</code> as in above. This will allow you to keep your installed packages separate between projects.</p> <p>Lightweight install with solely JPkl functionality without visualization:</p> <pre><code>git clone &lt;&lt;repo>>
cd jpkl
source activate YOURENVNAME
conda env update -f environment-novis.yml
pip install .</code></pre><h2 id=contributing>Contributing</h2> <p>I am more than happy to field pull requests! If interested, please post an issue for what you're thinking about working on so I can make sure it aligns with the vision for the project. The current guiding principle here is to keep it as lightweight / minimalistic as possible, though this is by no means set in stone.</p> <p>Areas of immediate interest for PRs:</p> <ul> <li>Multiprocessing for encoding / decoding (chunks of / whole) huge NumPy arrays quickly. Initial array encoding isn't incredibly fast, though random access for visualization is very usable. Multiprocessing might be a huge boon for the initial construction of the JPkls from arrays.</li> <li>Clever ways of caching frequently-accessed images might be useful in some cases.</li> <li>Other encoding / compression methods which may be superior to JPEG / Pickle files.</li> </ul> </div> <div class="svelte-dzuyvs callout-wrapper"> <div class="svelte-bf2rc0 callout"> <div class="svelte-bf2rc0 callout-content"> <h2>Interested in NIBR Engineering?</h2> <p>At NIBR, you'll be at the forefront of technology — helping to shape it, develop it, and make it impactful. Partnering with scientists, our engineers create cutting-edge, state-of-the-art solutions that accelerate drug discovery and ultimately improve patients’ lives.</p> <a class="primary svelte-zemmdc" class="btn primary" href=https://www.novartis.com/careers/careers-research rel="nofollow noopener" target=_blank variant=primary> Learn more </a> </div> </div> </div> </main> </div> <footer class=svelte-1o8yfks> <div class="svelte-1o8yfks footer-left"> © 2019 <a class=svelte-1o8yfks href=https://www.novartis.com rel="nofollow noreferrer" target=_blank>Novartis AG</a> <span class="svelte-1o8yfks sep"></span> <a class=svelte-1o8yfks href=https://www.novartis.com/terms-use rel="nofollow noreferrer" target=_blank> Terms of use </a> <span class="svelte-1o8yfks sep"></span> <a class=svelte-1o8yfks href=https://www.novartis.com/privacy-policy rel="nofollow noreferrer" target=_blank> Privacy policy </a> <span class="svelte-1o8yfks sep"></span> <a class=svelte-1o8yfks href=mailto:open.source@novartis.com> open.source@novartis.com </a> </div> <div class="svelte-1o8yfks footer-right social"> <a class=svelte-1o8yfks href=https://www.github.com/Novartis rel="nofollow noreferrer" target=_blank title=GitHub> <i class="fab fa-github"></i> </a> <a class=svelte-1o8yfks href=https://www.facebook.com/novartis rel="nofollow noreferrer" target=_blank title=Facebook> <i class="fab fa-facebook-f"></i> </a> <a class=svelte-1o8yfks href=https://twitter.com/NovartisScience rel="nofollow noreferrer" target=_blank title=Twitter> <i class="fab fa-twitter"></i> </a> <a class=svelte-1o8yfks href=https://www.linkedin.com/company/novartis-institutes-for-biomedical-research rel="nofollow noreferrer" target=_blank title=LinkedIn> <i class="fab fa-linkedin-in"></i> </a> </div> </footer></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,(function(a,b){return {project:{slug:a,metadata:{name:b,abbreviation:a,projectName:a,launched:"2018-09-18T00:00:00.000Z",summary:"Fast, compressed JPEG storage for NumPy applications.",description:"\u003Cp\u003ESerialize high memory \u002F disk consumption NumPy multidimensional arrays of images into JPEG-Pickle files for low storage cost and decently fast, random access with NumPy-like indexing.\u003C\u002Fp\u003E\n",dateString:"Tue Sep 18 2018",title:b,styles:[],scripts:[]},html:"\u003Cp\u003ESerialize high memory \u002F disk consumption NumPy multidimensional arrays of images into JPEG-Pickle files for low storage cost and decently fast, random access with NumPy-like indexing.\u003C\u002Fp\u003E\n\u003Cp\u003ECode at a glance:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-python\"\u003Eimport numpy as np\nfrom jpkl import JPkl\n\n# Make some arbitrary data. Say we have 512x512 images with time, z depth, and multiple channels.\nimages = np.zeros((512, 512, 100, 3, 2))\n\n# Automagically encode all 512x512 images into JPEGs.\njpkl_images = JPkl(images)\n\n# Index \u002F slice encoded JPEGs as you would a NumPy array.\n# JPEG-encoded slices are decoded and all concatenated into an array on-the-fly.\n\ndecoded_images = pkl_images[128:256:2, :, 4, ...]  # decoded_images is a NumPy array\n\ndecoded_images.shape  # (64, 512, 14, 15) [array is .squeeze()&#39;d as in NumPy indexing]\n\n# JPkl objects support 3 simple NumPy array properties.\n# This means you can sometimes get away with passing a JPkl instead of an array to functions.\n\njpkl_images.shape    # (512, 512, 100, 3, 2)\njpkl_images.ndim     # 5\njpkl_images.size     # 5505024000 [product of pkl_images.shape elements]\n\n# Pickle your JPkl and save to disk:\njpkl_images.save(&#39;pickled_images.jpkl&#39;)\n\n# Load a saved JPkl file:\nsaved_jpkl_images = JPkl.load(&#39;pickled_images.jpkl&#39;)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ENote that JPkl data is immutable from the high-level interface.\u003C\u002Fp\u003E\n\u003Cp\u003ESee the Jupyter Notebook demo for a more in-depth walkthrough (as well as a cool HoloViews visualization demo of scrubbing through these multidimensional arrays!).\u003C\u002Fp\u003E\n\u003Ch2 id=\"motivation\"\u003EMotivation\u003C\u002Fh2\u003E\n\u003Cp\u003EData from scientific imaging applications (such as microscopy) is often stored as raw, uncompressed data. This is important in cases where accurate quantification on pixel values is necessary. Due to this need, however, these image files (and their corresponding memory footprints) are often large, sometimes approaching 10s (or more) of gigabytes in extreme examples. While memory-mapping these files to access them without loading everything into memory is often a viable option, large I\u002FO speed demands due to the sizes of individual frames makes latency during visualization a possible issue. Additionally, this mapping still does not solve the issue of huge disk space consumption.\u003C\u002Fp\u003E\n\u003Cp\u003EAs such, to facilitate speedy visualization of the raw \u002F completely processed images as well as intermediate stage images (which you may not need to keep the uncompressed pixel values for anyway), it makes sense to lossily compress the images for non-computional, solely visualization purposes. JPkl handles this need by compressing all the individual image slices into JPEGs in memory which can then be serialized out to disk. Depending on image content and JPEG quality level, you can see massive (5-10x +) decreases in file size. In addition, JPkl supports on-the-fly decoding of abitrary slices of the pseudo-NumPy array into true NumPy arrays, meaning when you unpickle the JPkl file, your memory consumption remains as low as the file usage on disk unless you want to convert the whole JPkl into an array at once.\u003C\u002Fp\u003E\n\u003Cp\u003ENote that JPkl is not limited to using Pickle serialization or JPEG encoding. Extending the \u003Ccode\u003EJPkl\u003C\u002Fcode\u003E class and changing the implementations of \u003Ccode\u003Ejpkl_obj.save()\u003C\u002Fcode\u003E \u002F \u003Ccode\u003EJPkl.load()\u003C\u002Fcode\u003E or \u003Ccode\u003Ejpkl_obj.encode_slice()\u003C\u002Fcode\u003E \u002F \u003Ccode\u003Ejpkl_obj.decode_slice()\u003C\u002Fcode\u003E will allow you to use any serialization or encoding you wish as appropriate for your application, respectively.\u003C\u002Fp\u003E\n\u003Cp\u003EJPkl is most useful in the case where you have:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ELarge raw image datasets which you would like to visualize (such as in a Jupyter Notebook)\u003C\u002Fli\u003E\n\u003Cli\u003EDatasets that are highly multi-dimensional (x,y spatial + arbitrary number of time \u002F channel axes)\u003C\u002Fli\u003E\n\u003Cli\u003EThe need to visualize intermediate steps of image processing (which adds a multiplier on disk space consumption if\nintermediate steps are stored as raw images)\u003C\u002Fli\u003E\n\u003Cli\u003EThe desire to keep all images from a dataset \u002F NumPy array in a single file, rather than all messily dumped as separate .jpgs into the filesystem\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EJPkl uses the Pillow (PIL fork) library for encoding \u002F decoding JPEG images.\u003C\u002Fp\u003E\n\u003Ch2 id=\"attribution\"\u003EAttribution\u003C\u002Fh2\u003E\n\u003Cp\u003EThis is part of the Open Source at Novartis Institutes for BioMedical Research (NIBR) initiative:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fopensource.nibr.com\u002F\"\u003EOpen Source @ NIBR home\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FNovartis\u002F\"\u003EGitHub organization\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EIt is licensed under Apache License, Version 2.0.\u003C\u002Fp\u003E\n\u003Cp\u003EMaintainer: @zbarry\u003C\u002Fp\u003E\n\u003Ch2 id=\"jpkl-class-file-format-specification-\"\u003EJPkl class \u002F file format specification:\u003C\u002Fh2\u003E\n\u003Cp\u003EJPkls on disk are simply a dictionary of:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E&#39;header&#39;: Tuple of (&#39;JPkl&#39;, &#39;version&#39;), version in set{&#39;1&#39;}\n    Used for sanity checking if file on disk is JPkl file and is a loadable version.\n\n&#39;color&#39;: bool: if True, this came from a set of images with a color channel.\n    Therefore, the third axis [index 2] of the returned stack will be of length 3 for RGB.\n    Otherwise, there is no color axis.\n\n&#39;jpeg_quality&#39;: int: level of JPEG compression (0-100).\n\n&#39;images&#39;: Dictionary of byte streams from Pillow `Image` objects encoding images to `bytes` using `io.BytesIO` memory streams\n    Each key of the dictionary is a tuple of (channel 1, channel 2, ...) indices which correspond to a single image\n    slice. All images must be of the same width and height (since they are derived from \u002F decoded into NumPy arrays).\n    jpkl_obj.images[0, 5, 2], for example, returns a byte stream of the JPEG-encoded image slice which would have\n    been accessed in the original NumPy array as `image_array[:, :, 0, 5, 2]`. If the images were RGB, the color\n    axis is not a key in the dictionary.\n\n&#39;dim_names&#39;: List of strings of axis identities that come after height, width. Does not include color name. Not necessary for JPkl, but included for user&#39;s own documentation, if desired.\n\n&#39;dim_sizes&#39;: Tuple of the lengths of each channel axis. Does not include [height, width, RGB] axes.\n\n&#39;metadata&#39;: Dictionary of arbitrary data for the user&#39;s usage. Completely ignored by JPkl.\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2 id=\"installation\"\u003EInstallation\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cstrong\u003EDependencies (installation is through Anaconda system):\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"jpkl-\"\u003EJPkl:\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EPython &gt;= 3.6\u003C\u002Fli\u003E\n\u003Cli\u003ENumPy\u003C\u002Fli\u003E\n\u003Cli\u003EPillow (Python Imaging Library fork)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"jupyter-notebook-demo-\"\u003EJupyter Notebook demo:\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EJupyter Notebook \u002F Lab\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EHoloViews and associated libraries:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EParam\u003C\u002Fli\u003E\n\u003Cli\u003EParamBokeh\u003C\u002Fli\u003E\n\u003Cli\u003EBokeh\u003C\u002Fli\u003E\n\u003Cli\u003EImaGen\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"installation-procedure-\"\u003EInstallation procedure:\u003C\u002Fh3\u003E\n\u003Cp\u003EDefault installation including libraries enabling the notebook demo:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Egit clone &lt;&lt;repo&gt;&gt;\ncd jpkl\nsource activate YOURENVNAME\nconda env update -f environment.yml\npip install .\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003ESubstitute \u003Ccode\u003Epip install -e .\u003C\u002Fcode\u003E above if you wish to make edits to the source.\u003C\u002Fp\u003E\n\u003Cp\u003EWhile using a Conda environment is highly recommended in general, you can technically leave out the the \u003Ccode\u003Esource activate YOURENVNAME\u003C\u002Fcode\u003E line to install to the default package folder. If you&#39;ve not used Conda environments before, you can create one with \u003Ccode\u003Econda create -n YOURENVNAME\u003C\u002Fcode\u003E and then activate it with \u003Ccode\u003Esource activate YOURENVNAME\u003C\u002Fcode\u003E as in above. This will allow you to keep your installed packages separate between projects.\u003C\u002Fp\u003E\n\u003Cp\u003ELightweight install with solely JPkl functionality without visualization:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Egit clone &lt;&lt;repo&gt;&gt;\ncd jpkl\nsource activate YOURENVNAME\nconda env update -f environment-novis.yml\npip install .\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2 id=\"contributing\"\u003EContributing\u003C\u002Fh2\u003E\n\u003Cp\u003EI am more than happy to field pull requests! If interested, please post an issue for what you&#39;re thinking about working on so I can make sure it aligns with the vision for the project. The current guiding principle here is to keep it as lightweight \u002F minimalistic as possible, though this is by no means set in stone.\u003C\u002Fp\u003E\n\u003Cp\u003EAreas of immediate interest for PRs:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EMultiprocessing for encoding \u002F decoding (chunks of \u002F whole) huge NumPy arrays quickly. Initial array encoding isn&#39;t incredibly fast, though random access for visualization is very usable. Multiprocessing might be a huge boon for the initial construction of the JPkls from arrays.\u003C\u002Fli\u003E\n\u003Cli\u003EClever ways of caching frequently-accessed images might be useful in some cases.\u003C\u002Fli\u003E\n\u003Cli\u003EOther encoding \u002F compression methods which may be superior to JPEG \u002F Pickle files.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}}}("jpkl","JPkl"))],session:{basepath:"",forArtifactory:false}};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');</script><script src=/client/1ef9048e76cf74561a9e/main.js></script> 