{"slug":"peax","metadata":{"name":"Peax","abbreviation":"Peax","projectName":"peax","launched":"2018-09-15T00:00:00.000Z","icon":"/projects/peax/peax-icon.png","summary":"Interactive concept learning and visual exploration of epigenomic patterns.","description":"<p>Peax is a tool for interactive concept learning and exploration of epigenomic patterns based on unsupervised machine learning with autoencoders.</p>\n","dateString":"Sat Sep 15 2018","title":"Peax","styles":[],"scripts":[]},"html":"<blockquote>\n<p>A pattern explorer for epigenomic data.</p>\n</blockquote>\n<p><img src=\"/projects/peax/teaser.png\" alt=\"Peax&#39;s UI\"></p>\n<blockquote>\n<p>Epigenomic data expresses a rich body of diverse patterns that help to identify\nregulatory elements like promoter, enhancers, etc. But finding these patterns reliably\ngenome wide is challenging. Peax is a tool for interactive visual pattern search and\nexploration of epigenomic patterns based on unsupervised representation learning with\nconvolutional autoencoders. The visual search is driven by manually labeled genomic\nregions for actively learning a classifier to reflect your notion of interestingness.\nMore at <a href=\"http://peax.lekschas.de\">peax.lekschas.de</a>.</p>\n</blockquote>\n<h2 id=\"installation\">Installation</h2>\n<pre><code class=\"language-bash\">git clone https://github.com/Novartis/peax peax &amp;&amp; cd peax\nmake install</code></pre>\n<p><em>Do not fear, <code>make install</code> is just a convenience function for setting up conda and installing npm packages.</em></p>\n<p><strong>Notes:</strong></p>\n<ul>\n<li>If you&#39;re a macOS user you might need to <a href=\"https://brew.sh\">brew</a> install <code>libpng</code> and <code>openssl</code> for the <a href=\"https://github.com/nvictus/pybbi\">pybbi</a> package (see <a href=\"https://github.com/nvictus/pybbi/issues/2\">here</a>) and <code>xz</code> for pysam (if you see an error related to <code>lzma.h</code>).</li>\n</ul>\n<h2 id=\"overview\">Overview</h2>\n<p>Peax consists of three main parts:</p>\n<ol>\n<li>A server application for serving genomic and autoencoded data on the web. [<a href=\"https://github.com/Novartis/peax/tree/develop/server\">/server</a>].</li>\n<li>A user interface for exploring, visualizing, and interactively labeling genomic regions. [<a href=\"https://github.com/Novartis/peax/tree/develop/ui\">/ui</a>].</li>\n<li>A set of examples showing how to configure Peax and build your own. [<a href=\"https://github.com/Novartis/peax/tree/develop/examples\">/examples</a>]</li>\n</ol>\n<h2 id=\"data\">Data</h2>\n<p>We provide 6 autoencoders trained on 3 kb, 12 kb, and 120 kb window sizes (with 25,\n100, and 1000 bp binning) on DNase-seq and histone mark ChIP-seq data.</p>\n<p>You can find the autoencoder at <a href=\"https://zenodo.org/record/2609763\">zenodo.org/record/2609763</a>.</p>\n<h2 id=\"preprint\">Preprint</h2>\n<p>Lekschas et al., <a href=\"https://www.biorxiv.org/content/10.1101/597518v1\">Peax: Interactive Visual Pattern Search in Sequential Data Using Unsupervised Deep Representation Learning</a>,\n<em>bioRxiv</em>, 2019, doi: <a href=\"10.1101/597518\">10.1101/597518</a>.</p>\n<h2 id=\"quick-start\">Quick start</h2>\n<p>Peax comes with <a href=\"#autoencoders\">6 autoencoders</a> for DNase-seq and histone mark\nChIP-seq data and several example configurations for which we provide\nconvenience scripts to get you started as quickly as possible.</p>\n<p>For instance, run one of the following commands to start Peax with a DNase-seq\ntrack for 3 kb, 12 kb, and 120 kb genomic windows.</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Window Size</th>\n<th>Step Freq.</th>\n<th>Chromosomes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>make example-3kb</code></td>\n<td>3 kb</td>\n<td>2</td>\n<td>21</td>\n</tr>\n<tr>\n<td><code>make example-12kb</code></td>\n<td>12 kb</td>\n<td>3</td>\n<td>20-21</td>\n</tr>\n<tr>\n<td><code>make example-120kb</code></td>\n<td>120 kb</td>\n<td>6</td>\n<td>17-21</td>\n</tr>\n</tbody></table>\n<p><strong>Note:</strong> The first time Peax is started it will precompute the datasets for\nexploration. This can take a few minutes depending on your hardware. Also, these demos\nwill only prepare the above mentioned chromosomes, so don&#39;t try to search for patterns\non another chromosome. It won&#39;t work! For your own data you can freely configure this\nof course.</p>\n<p>The scripts will download test ENCODE tracks and use the matching\nconfiguration to start the server. More examples are described in <a href=\"https://github.com/Novartis/peax/tree/develop/examples\"><code>/examples</code></a>.</p>\n<h2 id=\"get-started\">Get Started</h2>\n<p>In the following we describe how you can configure Peax for your own data.</p>\n<h4 id=\"configure-peax-with-your-data\">Configure Peax with your data</h4>\n<p>Next, you need to configure Peax with your data to tell it which tracks you want to visualize in HiGlass and which of those tracks are encodable using an (auto)encoder.</p>\n<p>The fastest way to get started is to copy the example config:</p>\n<pre><code>cp config.json.sample config.json</code></pre><p>The config file has 6 top level properties:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Description</th>\n<th>Dtype</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>encoders</td>\n<td>List of encoders.</td>\n<td>list</td>\n</tr>\n<tr>\n<td>datasets</td>\n<td>List of tracks.</td>\n<td>list</td>\n</tr>\n<tr>\n<td>coords</td>\n<td>Genome coordinates. Peax currently supports hg19, hg28, mm9, and mm10</td>\n<td>str</td>\n</tr>\n<tr>\n<td>chroms</td>\n<td>Chromosomes to to be searched. If omitted all chromosomes will be prepared for searching.</td>\n<td>list</td>\n</tr>\n<tr>\n<td>step_freq</td>\n<td>Step frequency of the sliding window approach. E.g., given an encoder with window size 12 kb, a step frequency of 6 means that every 2 kb a 12 kb window will be extracted from the bigWig.</td>\n<td>int</td>\n</tr>\n<tr>\n<td>db_path</td>\n<td>Relative path to the sqlite db for storing searches.</td>\n<td>str</td>\n</tr>\n</tbody></table>\n<p>The main parts to adjust are <code>encoders</code> and <code>datasets</code>. <code>encoders</code> is a list of\n(auto)encoder definitions for different datatypes.T here are two ways to\nconfigure an (auto)encoder: (a) point to a pre-defined autoencoder or (b)\nconfigure from scratch.</p>\n<p>Assuming you want to use a predefined autoencoder all you have to do is</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Description</th>\n<th>Dtype</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>content_type</td>\n<td>Unique string identifying the autoencoder in the configuration file</td>\n<td>str</td>\n</tr>\n<tr>\n<td>from_file</td>\n<td>Relative path to the encoder configuration file.</td>\n<td>str</td>\n</tr>\n</tbody></table>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-json\">{\n  &quot;content_type&quot;: &quot;histone-mark-chip-seq-3kb&quot;,\n  &quot;from_file&quot;: &quot;examples/encoders.json&quot;\n}</code></pre>\n<p>The encoder configuration file is a dictionary with the top level keys acting\nas the identifier and need to match <code>content_type</code> above. Given the example\nfrom above the file could look like this:</p>\n<pre><code class=\"language-json\">{\n  &quot;histone-mark-chip-seq-3kb&quot;: {},\n  &quot;dnase-seq-3kb&quot;: {}\n}</code></pre>\n<p>See <code>[encoders.json](encoders.json)</code> for an example. The specific definition if an\nautoencoder is the same as described in the following.</p>\n<p>To configure an autoencoder from scratch you need to provide a dictionary with\nthe following required format:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Description</th>\n<th>Defaults</th>\n<th>Dtype</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>autoencoder</td>\n<td>Relative path to your pickled autoencoder model. (hdf5 file)</td>\n<td>&nbsp;</td>\n<td>str</td>\n</tr>\n<tr>\n<td>encoder</td>\n<td>Relative path to your pickled encoder model. (hdf5 file)</td>\n<td>&nbsp;</td>\n<td>str</td>\n</tr>\n<tr>\n<td>decoder</td>\n<td>Relative path to your pickled decoder model. (hdf5 file)</td>\n<td>&nbsp;</td>\n<td>str</td>\n</tr>\n<tr>\n<td>content_type</td>\n<td>Unique string describing the content this autoencoder can handle. Data tracks with the same content type will be encoded by this autoencoder.</td>\n<td>&nbsp;</td>\n<td>str</td>\n</tr>\n<tr>\n<td>window_size</td>\n<td>Window size in base pairs used for training the autoencoder.</td>\n<td>&nbsp;</td>\n<td>int</td>\n</tr>\n<tr>\n<td>resolution</td>\n<td>Resolution or bin size of the window in base pairs.</td>\n<td>&nbsp;</td>\n<td>int</td>\n</tr>\n<tr>\n<td>latent_dim</td>\n<td>Number of latent dimensions of the encoded windows.</td>\n<td>&nbsp;</td>\n<td>int</td>\n</tr>\n<tr>\n<td>input_dim</td>\n<td>Number of input dimensions for Keras. For 1D data these are 3: samples, data length (which is <code>window_size</code> / <code>resolution</code>), channels.</td>\n<td>3</td>\n<td>int</td>\n</tr>\n<tr>\n<td>channels</td>\n<td>Number of channels of the input data. This is normally 1.</td>\n<td>1</td>\n<td>int</td>\n</tr>\n</tbody></table>\n<p><em>Note that if you have specified an <code>autoencoder</code> you do not need to provide\nseparate <code>encoder</code> and <code>decoder</code> models.</em></p>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-json\">{\n  &quot;encoder&quot;: &quot;path/to/my-12kb-chip-seq-encoder.h5&quot;,\n  &quot;decoder&quot;: &quot;path/to/my-12kb-chip-seq-decoder.h5&quot;,\n  &quot;content_type&quot;: &quot;histone-mark-chip-seq&quot;,\n  &quot;window_size&quot;: 12000,\n  &quot;resolution&quot;: 100,\n  &quot;channels&quot;: 1,\n  &quot;input_dim&quot;: 3,\n  &quot;latent_dim&quot;: 12\n}</code></pre>\n<p>Datasets require the following format:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Description</th>\n<th>Dtype</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>filepath</td>\n<td>Relative path to the data file (bigWig or bigBed).</td>\n<td>str</td>\n</tr>\n<tr>\n<td>content_type</td>\n<td>Unique string describing the content this dataset. If you want to search for patterns in this track you need to have an autoencoder with a matching content type.</td>\n<td>str</td>\n</tr>\n<tr>\n<td>id</td>\n<td>A unique string identifying your track. (Optional)</td>\n<td>str</td>\n</tr>\n<tr>\n<td>name</td>\n<td>A human readable name to be shown in HiGlass. (Optional)</td>\n<td>str</td>\n</tr>\n</tbody></table>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-json\">{\n  &quot;filepath&quot;: &quot;data/chip-seq/my-fancy-gm12878-chip-seq-h3k27ac-fc-signal.bigWig&quot;,\n  &quot;content_type&quot;: &quot;histone-mark-chip-seq&quot;,\n  &quot;uuid&quot;: &quot;my-fancy-gm12878-chip-seq-h3k27c-track&quot;,\n  &quot;name&quot;: &quot;My Fancy GM12878 ChIP-Seq H3k27c Track&quot;\n}</code></pre>\n<h4 id=\"start-peax\">Start Peax</h4>\n<p>First, start the Peax server to serve your data.</p>\n<p><strong>Note:</strong> The first time you run Peax on a new dataset all the data will be prepared!\nDepending on your machine this can take some time. If you want to track the progress\nactivate the debugging mode using <code>-d</code>.</p>\n<pre><code class=\"language-bash\">python start.py</code></pre>\n<p>Now go to <a href=\"http://localhost:5000\">http://localhost:5000</a>.</p>\n<p>To <code>start.py</code> script supports the following options:</p>\n<pre><code class=\"language-bash\">usage: start.py [-h] [-c CONFIG] [--clear] [--clear-cache]\n                [--clear-cache-at-exit] [--clear-db] [-d] [--host HOST]\n                [--port PORT] [-v]\n\nPeak Explorer CLI\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        path to your JSON config file\n  --clear               clears the cache and database on startup\n  --clear-cache         clears the cache on startup\n  --clear-cache-at-exit\n                        clear the cache on shutdown\n  --clear-db            clears the database on startup\n  -d, --debug           turn on debug mode\n  --host HOST           customize the hostname\n  --port PORT           customize the port\n  -v, --verbose         turn verbose logging on</code></pre>\n<p>The <code>hostname</code> defaults to <code>localhost</code> and the <code>port</code> of the backend server defaults\nto <code>5000</code>.</p>\n<p>In order to speed up subsequend user interaction, Peax initially prepapres all\nthe data and caches that data under <code>/cache</code>. You can always remove this\ndirectory manually or clear the cache on startup or at exist using the <code>--clear</code>\nas specified above.</p>\n<hr>\n<h2 id=\"development\">Development</h2>\n<p>Handy commands to keep in mind:</p>\n<ul>\n<li><code>make install</code> installs the conda environment and npm packages and builds the UI</li>\n<li><code>make update</code> updates the conda environment and npm packages and rebuilds the UI</li>\n<li><code>make build</code> builds the UI</li>\n<li><code>./start.py</code> starts the Flask server application for serving data</li>\n<li>[/ui]: <code>npm install</code> installs and updates all the needed packages for the frontend</li>\n<li>[/ui]: <code>npm build</code> creates the production built of the frontend</li>\n<li>[/ui]: <code>npm start</code> starts a dev server with hot reloading for the frontend</li>\n</ul>\n<p>To start developing on the server and the ui in parallel, first start the backend server\napplication using <code>./start.py</code> and then start the frontend server application from\n<code>./ui</code> using <code>npm start</code>. Both server&#39;s watch the source code, so whenever you make\nchanges to the source code the servers will reload.</p>\n<h3 id=\"configuration\">Configuration</h3>\n<p>There are 2 types of configuration files. The <a href=\"#configure-peax-with-your-data\">backend server configuration</a>\ndefines the datasets to explore and is described in detail <a href=\"#configure-peax-with-your-data\">above</a>.</p>\n<p>Additionally, the frontend application can be configured to talk to a different backend\nserver and port if needed. Get started by copying the example configuration:</p>\n<pre><code class=\"language-bash\">cd ui &amp;&amp; cp config.json.sample config.json</code></pre>\n<p>By default the <code>server</code> is dynamically set to the hostname of the server running the\nfrontend application. I.e., it is assumed that the backend server application is\nrunning on the same host as the frontend application. The <code>port</code> of the server\ndefaults to <code>5000</code>.</p>\n<h3 id=\"start-the-backend-and-frontend-apps\">Start the backend and frontend apps</h3>\n<p>For development the backend and frontend applications run as seperate server\napplications.</p>\n<pre><code class=\"language-bash\"># Backend server\n./start.py --debug --config path/to/your/config.json\n\n# Frontend server\ncd ui &amp;&amp; npm start</code></pre>\n"}